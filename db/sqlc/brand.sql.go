// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.0
// source: brand.sql

package db

import (
	"context"
	"time"
)

const createBrand = `-- name: CreateBrand :one
INSERT INTO brands (
  name,
  meta_tags,
  slug,
  type,
  phone,
  email,
  email_verified,
  logo,
  banner,
  rating,
  vendor_id,
  prefix,
  status,
  availability,
  location,
  address
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
RETURNING id, name, meta_tags, slug, type, phone, email, email_verified, logo, banner, rating, vendor_id, prefix, status, availability, location, address, created_at
`

type CreateBrandParams struct {
	Name          string      `json:"name"`
	MetaTags      string      `json:"meta_tags"`
	Slug          string      `json:"slug"`
	Type          string      `json:"type"`
	Phone         string      `json:"phone"`
	Email         string      `json:"email"`
	EmailVerified bool        `json:"email_verified"`
	Logo          string      `json:"logo"`
	Banner        string      `json:"banner"`
	Rating        int32       `json:"rating"`
	VendorID      int64       `json:"vendor_id"`
	Prefix        string      `json:"prefix"`
	Status        string      `json:"status"`
	Availability  bool        `json:"availability"`
	Location      interface{} `json:"location"`
	Address       string      `json:"address"`
}

func (q *Queries) CreateBrand(ctx context.Context, arg CreateBrandParams) (Brand, error) {
	row := q.queryRow(ctx, q.createBrandStmt, createBrand,
		arg.Name,
		arg.MetaTags,
		arg.Slug,
		arg.Type,
		arg.Phone,
		arg.Email,
		arg.EmailVerified,
		arg.Logo,
		arg.Banner,
		arg.Rating,
		arg.VendorID,
		arg.Prefix,
		arg.Status,
		arg.Availability,
		arg.Location,
		arg.Address,
	)
	var i Brand
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.MetaTags,
		&i.Slug,
		&i.Type,
		&i.Phone,
		&i.Email,
		&i.EmailVerified,
		&i.Logo,
		&i.Banner,
		&i.Rating,
		&i.VendorID,
		&i.Prefix,
		&i.Status,
		&i.Availability,
		&i.Location,
		&i.Address,
		&i.CreatedAt,
	)
	return i, err
}

const createOperationTime = `-- name: CreateOperationTime :one
INSERT INTO operation_times (
  brand_id,
  day_of_week,
  start_time,
  end_time
) VALUES ($1, $2, $3, $4)
RETURNING id, brand_id, day_of_week, start_time, end_time, created_at
`

type CreateOperationTimeParams struct {
	BrandID   int64     `json:"brand_id"`
	DayOfWeek int32     `json:"day_of_week"`
	StartTime time.Time `json:"start_time"`
	EndTime   time.Time `json:"end_time"`
}

func (q *Queries) CreateOperationTime(ctx context.Context, arg CreateOperationTimeParams) (OperationTime, error) {
	row := q.queryRow(ctx, q.createOperationTimeStmt, createOperationTime,
		arg.BrandID,
		arg.DayOfWeek,
		arg.StartTime,
		arg.EndTime,
	)
	var i OperationTime
	err := row.Scan(
		&i.ID,
		&i.BrandID,
		&i.DayOfWeek,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
	)
	return i, err
}

const deleteBrand = `-- name: DeleteBrand :exec
DELETE FROM brands WHERE id = $1
`

func (q *Queries) DeleteBrand(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteBrandStmt, deleteBrand, id)
	return err
}

const deleteOperationTime = `-- name: DeleteOperationTime :exec
DELETE FROM operation_times WHERE id = $1
`

func (q *Queries) DeleteOperationTime(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteOperationTimeStmt, deleteOperationTime, id)
	return err
}

const getBrand = `-- name: GetBrand :one
SELECT id, name, meta_tags, slug, type, phone, email, email_verified, logo, banner, rating, vendor_id, prefix, status, availability, location, address, created_at FROM brands WHERE id = $1
`

func (q *Queries) GetBrand(ctx context.Context, id int64) (Brand, error) {
	row := q.queryRow(ctx, q.getBrandStmt, getBrand, id)
	var i Brand
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.MetaTags,
		&i.Slug,
		&i.Type,
		&i.Phone,
		&i.Email,
		&i.EmailVerified,
		&i.Logo,
		&i.Banner,
		&i.Rating,
		&i.VendorID,
		&i.Prefix,
		&i.Status,
		&i.Availability,
		&i.Location,
		&i.Address,
		&i.CreatedAt,
	)
	return i, err
}

const getOperationTime = `-- name: GetOperationTime :one
SELECT id, brand_id, day_of_week, start_time, end_time, created_at FROM operation_times WHERE id = $1
`

func (q *Queries) GetOperationTime(ctx context.Context, id int64) (OperationTime, error) {
	row := q.queryRow(ctx, q.getOperationTimeStmt, getOperationTime, id)
	var i OperationTime
	err := row.Scan(
		&i.ID,
		&i.BrandID,
		&i.DayOfWeek,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
	)
	return i, err
}

const listBrandIdsByVendorID = `-- name: ListBrandIdsByVendorID :many
SELECT id FROM brands WHERE vendor_id = $1
`

func (q *Queries) ListBrandIdsByVendorID(ctx context.Context, vendorID int64) ([]int64, error) {
	rows, err := q.query(ctx, q.listBrandIdsByVendorIDStmt, listBrandIdsByVendorID, vendorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBrands = `-- name: ListBrands :many
SELECT id, name, meta_tags, slug, type, phone, email, email_verified, logo, banner, rating, vendor_id, prefix, status, availability, location, address, created_at FROM brands ORDER BY id LIMIT $1 OFFSET $2
`

type ListBrandsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListBrands(ctx context.Context, arg ListBrandsParams) ([]Brand, error) {
	rows, err := q.query(ctx, q.listBrandsStmt, listBrands, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Brand{}
	for rows.Next() {
		var i Brand
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MetaTags,
			&i.Slug,
			&i.Type,
			&i.Phone,
			&i.Email,
			&i.EmailVerified,
			&i.Logo,
			&i.Banner,
			&i.Rating,
			&i.VendorID,
			&i.Prefix,
			&i.Status,
			&i.Availability,
			&i.Location,
			&i.Address,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBrandsByVendorID = `-- name: ListBrandsByVendorID :many
SELECT id, name, meta_tags, slug, type, phone, email, email_verified, logo, banner, rating, vendor_id, prefix, status, availability, location, address, created_at FROM brands WHERE vendor_id = $1 ORDER BY id LIMIT $2 OFFSET $3
`

type ListBrandsByVendorIDParams struct {
	VendorID int64 `json:"vendor_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

func (q *Queries) ListBrandsByVendorID(ctx context.Context, arg ListBrandsByVendorIDParams) ([]Brand, error) {
	rows, err := q.query(ctx, q.listBrandsByVendorIDStmt, listBrandsByVendorID, arg.VendorID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Brand{}
	for rows.Next() {
		var i Brand
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.MetaTags,
			&i.Slug,
			&i.Type,
			&i.Phone,
			&i.Email,
			&i.EmailVerified,
			&i.Logo,
			&i.Banner,
			&i.Rating,
			&i.VendorID,
			&i.Prefix,
			&i.Status,
			&i.Availability,
			&i.Location,
			&i.Address,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOperationTimesByBrandId = `-- name: ListOperationTimesByBrandId :many
SELECT id, brand_id, day_of_week, start_time, end_time, created_at FROM operation_times WHERE brand_id = $1 ORDER BY id LIMIT $2 OFFSET $3
`

type ListOperationTimesByBrandIdParams struct {
	BrandID int64 `json:"brand_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) ListOperationTimesByBrandId(ctx context.Context, arg ListOperationTimesByBrandIdParams) ([]OperationTime, error) {
	rows, err := q.query(ctx, q.listOperationTimesByBrandIdStmt, listOperationTimesByBrandId, arg.BrandID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OperationTime{}
	for rows.Next() {
		var i OperationTime
		if err := rows.Scan(
			&i.ID,
			&i.BrandID,
			&i.DayOfWeek,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBrand = `-- name: UpdateBrand :one
UPDATE brands SET
  name = $2,
  meta_tags = $3,
  slug = $4,
  type = $5,
  phone = $6,
  email = $7,
  email_verified = $8,
  logo = $9,
  banner = $10,
  rating = $11,
  vendor_id = $12,
  prefix = $13,
  status = $14,
  availability = $15,
  location = $16,
  address = $17
WHERE id = $1
RETURNING id, name, meta_tags, slug, type, phone, email, email_verified, logo, banner, rating, vendor_id, prefix, status, availability, location, address, created_at
`

type UpdateBrandParams struct {
	ID            int64       `json:"id"`
	Name          string      `json:"name"`
	MetaTags      string      `json:"meta_tags"`
	Slug          string      `json:"slug"`
	Type          string      `json:"type"`
	Phone         string      `json:"phone"`
	Email         string      `json:"email"`
	EmailVerified bool        `json:"email_verified"`
	Logo          string      `json:"logo"`
	Banner        string      `json:"banner"`
	Rating        int32       `json:"rating"`
	VendorID      int64       `json:"vendor_id"`
	Prefix        string      `json:"prefix"`
	Status        string      `json:"status"`
	Availability  bool        `json:"availability"`
	Location      interface{} `json:"location"`
	Address       string      `json:"address"`
}

func (q *Queries) UpdateBrand(ctx context.Context, arg UpdateBrandParams) (Brand, error) {
	row := q.queryRow(ctx, q.updateBrandStmt, updateBrand,
		arg.ID,
		arg.Name,
		arg.MetaTags,
		arg.Slug,
		arg.Type,
		arg.Phone,
		arg.Email,
		arg.EmailVerified,
		arg.Logo,
		arg.Banner,
		arg.Rating,
		arg.VendorID,
		arg.Prefix,
		arg.Status,
		arg.Availability,
		arg.Location,
		arg.Address,
	)
	var i Brand
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.MetaTags,
		&i.Slug,
		&i.Type,
		&i.Phone,
		&i.Email,
		&i.EmailVerified,
		&i.Logo,
		&i.Banner,
		&i.Rating,
		&i.VendorID,
		&i.Prefix,
		&i.Status,
		&i.Availability,
		&i.Location,
		&i.Address,
		&i.CreatedAt,
	)
	return i, err
}

const updateOperationTime = `-- name: UpdateOperationTime :one
UPDATE operation_times SET
  brand_id = $2,
  day_of_week = $3,
  start_time = $4,
  end_time = $5
WHERE id = $1
RETURNING id, brand_id, day_of_week, start_time, end_time, created_at
`

type UpdateOperationTimeParams struct {
	ID        int64     `json:"id"`
	BrandID   int64     `json:"brand_id"`
	DayOfWeek int32     `json:"day_of_week"`
	StartTime time.Time `json:"start_time"`
	EndTime   time.Time `json:"end_time"`
}

func (q *Queries) UpdateOperationTime(ctx context.Context, arg UpdateOperationTimeParams) (OperationTime, error) {
	row := q.queryRow(ctx, q.updateOperationTimeStmt, updateOperationTime,
		arg.ID,
		arg.BrandID,
		arg.DayOfWeek,
		arg.StartTime,
		arg.EndTime,
	)
	var i OperationTime
	err := row.Scan(
		&i.ID,
		&i.BrandID,
		&i.DayOfWeek,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
	)
	return i, err
}
