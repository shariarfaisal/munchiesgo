// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.0
// source: zone.sql

package db

import (
	"context"
	"database/sql"
)

const countZones = `-- name: CountZones :one
SELECT COUNT(*) FROM zones
`

func (q *Queries) CountZones(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countZonesStmt, countZones)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countZonesByBrandID = `-- name: CountZonesByBrandID :one
SELECT COUNT(*) FROM zones WHERE id IN (SELECT zone_id FROM brand_zones WHERE brand_id = $1)
`

func (q *Queries) CountZonesByBrandID(ctx context.Context, brandID int32) (int64, error) {
	row := q.queryRow(ctx, q.countZonesByBrandIDStmt, countZonesByBrandID, brandID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBrandZone = `-- name: CreateBrandZone :one
INSERT INTO brand_zones (
  brand_id,
  zone_id
) VALUES ($1, $2)
RETURNING id, brand_id, zone_id, created_at
`

type CreateBrandZoneParams struct {
	BrandID int32 `json:"brand_id"`
	ZoneID  int32 `json:"zone_id"`
}

func (q *Queries) CreateBrandZone(ctx context.Context, arg CreateBrandZoneParams) (BrandZone, error) {
	row := q.queryRow(ctx, q.createBrandZoneStmt, createBrandZone, arg.BrandID, arg.ZoneID)
	var i BrandZone
	err := row.Scan(
		&i.ID,
		&i.BrandID,
		&i.ZoneID,
		&i.CreatedAt,
	)
	return i, err
}

const createZone = `-- name: CreateZone :one


INSERT INTO zones (
  name,
  boundary
) VALUES ($1, $2)
RETURNING id, name, boundary, created_at
`

type CreateZoneParams struct {
	Name     sql.NullString `json:"name"`
	Boundary interface{}    `json:"boundary"`
}

// CREATE TABLE "zones" (
//
//	"id" int PRIMARY KEY,
//	"name" varchar,
//	"boundary" "geography(Polygon, 4326)",
//	"created_at" timestamptz NOT NULL DEFAULT (now())
//
// );
// CREATE TABLE "brand_zones" (
//
//	"id" int PRIMARY KEY,
//	"brand_id" int NOT NULL,
//	"zone_id" int NOT NULL,
//	"created_at" timestamptz NOT NULL DEFAULT (now())
//
// );
func (q *Queries) CreateZone(ctx context.Context, arg CreateZoneParams) (Zone, error) {
	row := q.queryRow(ctx, q.createZoneStmt, createZone, arg.Name, arg.Boundary)
	var i Zone
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Boundary,
		&i.CreatedAt,
	)
	return i, err
}

const deleteBrandZone = `-- name: DeleteBrandZone :exec
DELETE FROM brand_zones WHERE brand_id = $1 AND zone_id = $2
`

type DeleteBrandZoneParams struct {
	BrandID int32 `json:"brand_id"`
	ZoneID  int32 `json:"zone_id"`
}

func (q *Queries) DeleteBrandZone(ctx context.Context, arg DeleteBrandZoneParams) error {
	_, err := q.exec(ctx, q.deleteBrandZoneStmt, deleteBrandZone, arg.BrandID, arg.ZoneID)
	return err
}

const deleteZone = `-- name: DeleteZone :exec
DELETE FROM zones WHERE id = $1
`

func (q *Queries) DeleteZone(ctx context.Context, id int32) error {
	_, err := q.exec(ctx, q.deleteZoneStmt, deleteZone, id)
	return err
}

const getZone = `-- name: GetZone :one
SELECT id, name, boundary, created_at FROM zones WHERE id = $1
`

func (q *Queries) GetZone(ctx context.Context, id int32) (Zone, error) {
	row := q.queryRow(ctx, q.getZoneStmt, getZone, id)
	var i Zone
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Boundary,
		&i.CreatedAt,
	)
	return i, err
}

const listBrandZones = `-- name: ListBrandZones :many
SELECT id, brand_id, zone_id, created_at FROM brand_zones WHERE brand_id = $1 ORDER BY id LIMIT $2 OFFSET $3
`

type ListBrandZonesParams struct {
	BrandID int32 `json:"brand_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) ListBrandZones(ctx context.Context, arg ListBrandZonesParams) ([]BrandZone, error) {
	rows, err := q.query(ctx, q.listBrandZonesStmt, listBrandZones, arg.BrandID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BrandZone{}
	for rows.Next() {
		var i BrandZone
		if err := rows.Scan(
			&i.ID,
			&i.BrandID,
			&i.ZoneID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listZones = `-- name: ListZones :many
SELECT id, name, boundary, created_at FROM zones ORDER BY id LIMIT $1 OFFSET $2
`

type ListZonesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListZones(ctx context.Context, arg ListZonesParams) ([]Zone, error) {
	rows, err := q.query(ctx, q.listZonesStmt, listZones, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Zone{}
	for rows.Next() {
		var i Zone
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Boundary,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listZonesByBrandID = `-- name: ListZonesByBrandID :many
SELECT id, name, boundary, created_at FROM zones WHERE id IN (SELECT zone_id FROM brand_zones WHERE brand_id = $1) ORDER BY id LIMIT $2 OFFSET $3
`

type ListZonesByBrandIDParams struct {
	BrandID int32 `json:"brand_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) ListZonesByBrandID(ctx context.Context, arg ListZonesByBrandIDParams) ([]Zone, error) {
	rows, err := q.query(ctx, q.listZonesByBrandIDStmt, listZonesByBrandID, arg.BrandID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Zone{}
	for rows.Next() {
		var i Zone
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Boundary,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchZones = `-- name: SearchZones :many
SELECT id, name, boundary, created_at FROM zones
WHERE name ILIKE $1 ORDER BY id LIMIT $2 OFFSET $3
`

type SearchZonesParams struct {
	Name   sql.NullString `json:"name"`
	Limit  int32          `json:"limit"`
	Offset int32          `json:"offset"`
}

func (q *Queries) SearchZones(ctx context.Context, arg SearchZonesParams) ([]Zone, error) {
	rows, err := q.query(ctx, q.searchZonesStmt, searchZones, arg.Name, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Zone{}
	for rows.Next() {
		var i Zone
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Boundary,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchZonesByBrandID = `-- name: SearchZonesByBrandID :many
SELECT id, name, boundary, created_at FROM zones
WHERE id IN (SELECT zone_id FROM brand_zones WHERE brand_id = $2) AND name ILIKE $1 ORDER BY id LIMIT $3 OFFSET $4
`

type SearchZonesByBrandIDParams struct {
	Name    sql.NullString `json:"name"`
	BrandID int32          `json:"brand_id"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

func (q *Queries) SearchZonesByBrandID(ctx context.Context, arg SearchZonesByBrandIDParams) ([]Zone, error) {
	rows, err := q.query(ctx, q.searchZonesByBrandIDStmt, searchZonesByBrandID,
		arg.Name,
		arg.BrandID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Zone{}
	for rows.Next() {
		var i Zone
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Boundary,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchZonesByGeoPoint = `-- name: SearchZonesByGeoPoint :many
SELECT id, name, boundary, created_at FROM zones
WHERE ST_Intersects(boundary, ST_GeomFromText('POINT(' || $1 || ' ' || $2 || ')', 4326))
ORDER BY id LIMIT $3 OFFSET $4
`

type SearchZonesByGeoPointParams struct {
	Column1 sql.NullString `json:"column_1"`
	Column2 sql.NullString `json:"column_2"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

func (q *Queries) SearchZonesByGeoPoint(ctx context.Context, arg SearchZonesByGeoPointParams) ([]Zone, error) {
	rows, err := q.query(ctx, q.searchZonesByGeoPointStmt, searchZonesByGeoPoint,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Zone{}
	for rows.Next() {
		var i Zone
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Boundary,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchZonesByGeoPointAndBrandID = `-- name: SearchZonesByGeoPointAndBrandID :many
SELECT id, name, boundary, created_at FROM zones
WHERE id IN (SELECT zone_id FROM brand_zones WHERE brand_id = $3) AND ST_Intersects(boundary, ST_GeomFromText('POINT(' || $1 || ' ' || $2 || ')', 4326))
ORDER BY id LIMIT $4 OFFSET $5
`

type SearchZonesByGeoPointAndBrandIDParams struct {
	Column1 sql.NullString `json:"column_1"`
	Column2 sql.NullString `json:"column_2"`
	BrandID int32          `json:"brand_id"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

func (q *Queries) SearchZonesByGeoPointAndBrandID(ctx context.Context, arg SearchZonesByGeoPointAndBrandIDParams) ([]Zone, error) {
	rows, err := q.query(ctx, q.searchZonesByGeoPointAndBrandIDStmt, searchZonesByGeoPointAndBrandID,
		arg.Column1,
		arg.Column2,
		arg.BrandID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Zone{}
	for rows.Next() {
		var i Zone
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Boundary,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchZonesByGeoPolygon = `-- name: SearchZonesByGeoPolygon :many
SELECT id, name, boundary, created_at FROM zones
WHERE ST_Intersects(boundary, ST_GeomFromText('POLYGON((' || $1 || '))', 4326))
ORDER BY id LIMIT $2 OFFSET $3
`

type SearchZonesByGeoPolygonParams struct {
	Column1 sql.NullString `json:"column_1"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

func (q *Queries) SearchZonesByGeoPolygon(ctx context.Context, arg SearchZonesByGeoPolygonParams) ([]Zone, error) {
	rows, err := q.query(ctx, q.searchZonesByGeoPolygonStmt, searchZonesByGeoPolygon, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Zone{}
	for rows.Next() {
		var i Zone
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Boundary,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchZonesByGeoPolygonAndBrandID = `-- name: SearchZonesByGeoPolygonAndBrandID :many
SELECT id, name, boundary, created_at FROM zones
WHERE id IN (SELECT zone_id FROM brand_zones WHERE brand_id = $2) AND ST_Intersects(boundary, ST_GeomFromText('POLYGON((' || $1 || '))', 4326))
ORDER BY id LIMIT $3 OFFSET $4
`

type SearchZonesByGeoPolygonAndBrandIDParams struct {
	Column1 sql.NullString `json:"column_1"`
	BrandID int32          `json:"brand_id"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

func (q *Queries) SearchZonesByGeoPolygonAndBrandID(ctx context.Context, arg SearchZonesByGeoPolygonAndBrandIDParams) ([]Zone, error) {
	rows, err := q.query(ctx, q.searchZonesByGeoPolygonAndBrandIDStmt, searchZonesByGeoPolygonAndBrandID,
		arg.Column1,
		arg.BrandID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Zone{}
	for rows.Next() {
		var i Zone
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Boundary,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateZone = `-- name: UpdateZone :one
UPDATE zones SET
  name = $2,
  boundary = $3
WHERE id = $1
RETURNING id, name, boundary, created_at
`

type UpdateZoneParams struct {
	ID       int32          `json:"id"`
	Name     sql.NullString `json:"name"`
	Boundary interface{}    `json:"boundary"`
}

func (q *Queries) UpdateZone(ctx context.Context, arg UpdateZoneParams) (Zone, error) {
	row := q.queryRow(ctx, q.updateZoneStmt, updateZone, arg.ID, arg.Name, arg.Boundary)
	var i Zone
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Boundary,
		&i.CreatedAt,
	)
	return i, err
}
