// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.0
// source: inventory.sql

package db

import (
	"context"
	"time"
)

const countInventoryHistory = `-- name: CountInventoryHistory :one
SELECT COUNT(*) FROM inventory_history WHERE product_id = $1
`

func (q *Queries) CountInventoryHistory(ctx context.Context, productID int64) (int64, error) {
	row := q.queryRow(ctx, q.countInventoryHistoryStmt, countInventoryHistory, productID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countInventoryHistoryByProductId = `-- name: CountInventoryHistoryByProductId :one
SELECT COUNT(*) FROM inventory_history WHERE product_id = $1
`

func (q *Queries) CountInventoryHistoryByProductId(ctx context.Context, productID int64) (int64, error) {
	row := q.queryRow(ctx, q.countInventoryHistoryByProductIdStmt, countInventoryHistoryByProductId, productID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProductInventory = `-- name: CountProductInventory :one
SELECT COUNT(*) FROM product_inventory WHERE product_id = $1
`

func (q *Queries) CountProductInventory(ctx context.Context, productID int64) (int64, error) {
	row := q.queryRow(ctx, q.countProductInventoryStmt, countProductInventory, productID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProductInventoryByProductId = `-- name: CountProductInventoryByProductId :one
SELECT COUNT(*) FROM product_inventory WHERE product_id = $1
`

func (q *Queries) CountProductInventoryByProductId(ctx context.Context, productID int64) (int64, error) {
	row := q.queryRow(ctx, q.countProductInventoryByProductIdStmt, countProductInventoryByProductId, productID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInventoryHistory = `-- name: CreateInventoryHistory :one
INSERT INTO inventory_history (
    product_id,
    quantity,
    type
    ) VALUES ($1, $2, $3)
RETURNING id, product_id, quantity, type, created_at
`

type CreateInventoryHistoryParams struct {
	ProductID int64  `json:"product_id"`
	Quantity  int32  `json:"quantity"`
	Type      string `json:"type"`
}

func (q *Queries) CreateInventoryHistory(ctx context.Context, arg CreateInventoryHistoryParams) (InventoryHistory, error) {
	row := q.queryRow(ctx, q.createInventoryHistoryStmt, createInventoryHistory, arg.ProductID, arg.Quantity, arg.Type)
	var i InventoryHistory
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Quantity,
		&i.Type,
		&i.CreatedAt,
	)
	return i, err
}

const createProductInventory = `-- name: CreateProductInventory :one
INSERT INTO product_inventory (
    product_id,
    quantity,
    purchase_price,
    selling_price,
    expire_date
    ) VALUES ($1, $2, $3, $4, $5)
RETURNING id, product_id, quantity, purchase_price, selling_price, expire_date, created_at, updated_at
`

type CreateProductInventoryParams struct {
	ProductID     int64     `json:"product_id"`
	Quantity      int32     `json:"quantity"`
	PurchasePrice float64   `json:"purchase_price"`
	SellingPrice  float64   `json:"selling_price"`
	ExpireDate    time.Time `json:"expire_date"`
}

func (q *Queries) CreateProductInventory(ctx context.Context, arg CreateProductInventoryParams) (ProductInventory, error) {
	row := q.queryRow(ctx, q.createProductInventoryStmt, createProductInventory,
		arg.ProductID,
		arg.Quantity,
		arg.PurchasePrice,
		arg.SellingPrice,
		arg.ExpireDate,
	)
	var i ProductInventory
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Quantity,
		&i.PurchasePrice,
		&i.SellingPrice,
		&i.ExpireDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteInventoryHistory = `-- name: DeleteInventoryHistory :exec
DELETE FROM inventory_history WHERE id = $1
`

func (q *Queries) DeleteInventoryHistory(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteInventoryHistoryStmt, deleteInventoryHistory, id)
	return err
}

const deleteProductInventory = `-- name: DeleteProductInventory :exec
DELETE FROM product_inventory WHERE id = $1
`

func (q *Queries) DeleteProductInventory(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteProductInventoryStmt, deleteProductInventory, id)
	return err
}

const getInventoryHistory = `-- name: GetInventoryHistory :one
SELECT id, product_id, quantity, type, created_at FROM inventory_history WHERE id = $1
`

func (q *Queries) GetInventoryHistory(ctx context.Context, id int64) (InventoryHistory, error) {
	row := q.queryRow(ctx, q.getInventoryHistoryStmt, getInventoryHistory, id)
	var i InventoryHistory
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Quantity,
		&i.Type,
		&i.CreatedAt,
	)
	return i, err
}

const getInventoryHistoryByProductID = `-- name: GetInventoryHistoryByProductID :one
SELECT id, product_id, quantity, type, created_at FROM inventory_history WHERE product_id = $1
`

func (q *Queries) GetInventoryHistoryByProductID(ctx context.Context, productID int64) (InventoryHistory, error) {
	row := q.queryRow(ctx, q.getInventoryHistoryByProductIDStmt, getInventoryHistoryByProductID, productID)
	var i InventoryHistory
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Quantity,
		&i.Type,
		&i.CreatedAt,
	)
	return i, err
}

const getProductInventory = `-- name: GetProductInventory :one
SELECT id, product_id, quantity, purchase_price, selling_price, expire_date, created_at, updated_at FROM product_inventory WHERE id = $1
`

func (q *Queries) GetProductInventory(ctx context.Context, id int64) (ProductInventory, error) {
	row := q.queryRow(ctx, q.getProductInventoryStmt, getProductInventory, id)
	var i ProductInventory
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Quantity,
		&i.PurchasePrice,
		&i.SellingPrice,
		&i.ExpireDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductInventoryByProductID = `-- name: GetProductInventoryByProductID :one
SELECT id, product_id, quantity, purchase_price, selling_price, expire_date, created_at, updated_at FROM product_inventory WHERE product_id = $1
`

func (q *Queries) GetProductInventoryByProductID(ctx context.Context, productID int64) (ProductInventory, error) {
	row := q.queryRow(ctx, q.getProductInventoryByProductIDStmt, getProductInventoryByProductID, productID)
	var i ProductInventory
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Quantity,
		&i.PurchasePrice,
		&i.SellingPrice,
		&i.ExpireDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listInventoryHistory = `-- name: ListInventoryHistory :many
SELECT id, product_id, quantity, type, created_at FROM inventory_history WHERE product_id = $1 ORDER BY id LIMIT $2 OFFSET $3
`

type ListInventoryHistoryParams struct {
	ProductID int64 `json:"product_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) ListInventoryHistory(ctx context.Context, arg ListInventoryHistoryParams) ([]InventoryHistory, error) {
	rows, err := q.query(ctx, q.listInventoryHistoryStmt, listInventoryHistory, arg.ProductID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InventoryHistory{}
	for rows.Next() {
		var i InventoryHistory
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Quantity,
			&i.Type,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductInventory = `-- name: ListProductInventory :many
SELECT id, product_id, quantity, purchase_price, selling_price, expire_date, created_at, updated_at FROM product_inventory WHERE product_id = $1 ORDER BY id LIMIT $2 OFFSET $3
`

type ListProductInventoryParams struct {
	ProductID int64 `json:"product_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) ListProductInventory(ctx context.Context, arg ListProductInventoryParams) ([]ProductInventory, error) {
	rows, err := q.query(ctx, q.listProductInventoryStmt, listProductInventory, arg.ProductID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductInventory{}
	for rows.Next() {
		var i ProductInventory
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Quantity,
			&i.PurchasePrice,
			&i.SellingPrice,
			&i.ExpireDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchInventoryHistory = `-- name: SearchInventoryHistory :many
SELECT id, product_id, quantity, type, created_at FROM inventory_history
WHERE product_id = $1 AND (quantity ILIKE $2 OR type ILIKE $2) ORDER BY id LIMIT $3 OFFSET $4
`

type SearchInventoryHistoryParams struct {
	ProductID int64 `json:"product_id"`
	Quantity  int32 `json:"quantity"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) SearchInventoryHistory(ctx context.Context, arg SearchInventoryHistoryParams) ([]InventoryHistory, error) {
	rows, err := q.query(ctx, q.searchInventoryHistoryStmt, searchInventoryHistory,
		arg.ProductID,
		arg.Quantity,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InventoryHistory{}
	for rows.Next() {
		var i InventoryHistory
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Quantity,
			&i.Type,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProductInventory = `-- name: SearchProductInventory :many
SELECT id, product_id, quantity, purchase_price, selling_price, expire_date, created_at, updated_at FROM product_inventory
WHERE product_id = $1 AND (quantity ILIKE $2 OR purchase_price ILIKE $2 OR selling_price ILIKE $2 OR expire_date ILIKE $2) ORDER BY id LIMIT $3 OFFSET $4
`

type SearchProductInventoryParams struct {
	ProductID int64 `json:"product_id"`
	Quantity  int32 `json:"quantity"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) SearchProductInventory(ctx context.Context, arg SearchProductInventoryParams) ([]ProductInventory, error) {
	rows, err := q.query(ctx, q.searchProductInventoryStmt, searchProductInventory,
		arg.ProductID,
		arg.Quantity,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductInventory{}
	for rows.Next() {
		var i ProductInventory
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Quantity,
			&i.PurchasePrice,
			&i.SellingPrice,
			&i.ExpireDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInventoryHistory = `-- name: UpdateInventoryHistory :one
UPDATE inventory_history SET
    product_id = $2,
    quantity = $3,
    type = $4
WHERE id = $1
RETURNING id, product_id, quantity, type, created_at
`

type UpdateInventoryHistoryParams struct {
	ID        int64  `json:"id"`
	ProductID int64  `json:"product_id"`
	Quantity  int32  `json:"quantity"`
	Type      string `json:"type"`
}

func (q *Queries) UpdateInventoryHistory(ctx context.Context, arg UpdateInventoryHistoryParams) (InventoryHistory, error) {
	row := q.queryRow(ctx, q.updateInventoryHistoryStmt, updateInventoryHistory,
		arg.ID,
		arg.ProductID,
		arg.Quantity,
		arg.Type,
	)
	var i InventoryHistory
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Quantity,
		&i.Type,
		&i.CreatedAt,
	)
	return i, err
}

const updateProductInventory = `-- name: UpdateProductInventory :one
UPDATE product_inventory SET
    quantity = $2,
    purchase_price = $3,
    selling_price = $4,
    expire_date = $5
WHERE id = $1
RETURNING id, product_id, quantity, purchase_price, selling_price, expire_date, created_at, updated_at
`

type UpdateProductInventoryParams struct {
	ID            int64     `json:"id"`
	Quantity      int32     `json:"quantity"`
	PurchasePrice float64   `json:"purchase_price"`
	SellingPrice  float64   `json:"selling_price"`
	ExpireDate    time.Time `json:"expire_date"`
}

func (q *Queries) UpdateProductInventory(ctx context.Context, arg UpdateProductInventoryParams) (ProductInventory, error) {
	row := q.queryRow(ctx, q.updateProductInventoryStmt, updateProductInventory,
		arg.ID,
		arg.Quantity,
		arg.PurchasePrice,
		arg.SellingPrice,
		arg.ExpireDate,
	)
	var i ProductInventory
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Quantity,
		&i.PurchasePrice,
		&i.SellingPrice,
		&i.ExpireDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
