// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.0
// source: order.sql

package db

import (
	"context"
	"time"
)

const createBrandOrder = `-- name: CreateBrandOrder :one
INSERT INTO brand_orders (brand_id, order_id, status, total, discount, note)
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, brand_id, order_id, status, total, discount, note
`

type CreateBrandOrderParams struct {
	BrandID  int64   `json:"brand_id"`
	OrderID  int64   `json:"order_id"`
	Status   string  `json:"status"`
	Total    float64 `json:"total"`
	Discount float64 `json:"discount"`
	Note     string  `json:"note"`
}

func (q *Queries) CreateBrandOrder(ctx context.Context, arg CreateBrandOrderParams) (BrandOrder, error) {
	row := q.queryRow(ctx, q.createBrandOrderStmt, createBrandOrder,
		arg.BrandID,
		arg.OrderID,
		arg.Status,
		arg.Total,
		arg.Discount,
		arg.Note,
	)
	var i BrandOrder
	err := row.Scan(
		&i.ID,
		&i.BrandID,
		&i.OrderID,
		&i.Status,
		&i.Total,
		&i.Discount,
		&i.Note,
	)
	return i, err
}

const createDeliveryAddress = `-- name: CreateDeliveryAddress :one
INSERT INTO delivery_address (order_id, customer_id, address, geo_point, apartment, area, floor, phone)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id, order_id, customer_id, address, geo_point, apartment, area, floor, phone
`

type CreateDeliveryAddressParams struct {
	OrderID    int64       `json:"order_id"`
	CustomerID int64       `json:"customer_id"`
	Address    string      `json:"address"`
	GeoPoint   interface{} `json:"geo_point"`
	Apartment  string      `json:"apartment"`
	Area       string      `json:"area"`
	Floor      string      `json:"floor"`
	Phone      string      `json:"phone"`
}

func (q *Queries) CreateDeliveryAddress(ctx context.Context, arg CreateDeliveryAddressParams) (DeliveryAddress, error) {
	row := q.queryRow(ctx, q.createDeliveryAddressStmt, createDeliveryAddress,
		arg.OrderID,
		arg.CustomerID,
		arg.Address,
		arg.GeoPoint,
		arg.Apartment,
		arg.Area,
		arg.Floor,
		arg.Phone,
	)
	var i DeliveryAddress
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.CustomerID,
		&i.Address,
		&i.GeoPoint,
		&i.Apartment,
		&i.Area,
		&i.Floor,
		&i.Phone,
	)
	return i, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (customer_id, status, payment_method, payment_status, rider_note, dispatch_time, total, total_discount, service_charge, payable)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING id, customer_id, status, payment_method, payment_status, rider_note, dispatch_time, total, total_discount, service_charge, payable, created_at, updated_at
`

type CreateOrderParams struct {
	CustomerID    int64     `json:"customer_id"`
	Status        string    `json:"status"`
	PaymentMethod string    `json:"payment_method"`
	PaymentStatus string    `json:"payment_status"`
	RiderNote     string    `json:"rider_note"`
	DispatchTime  time.Time `json:"dispatch_time"`
	Total         float64   `json:"total"`
	TotalDiscount float64   `json:"total_discount"`
	ServiceCharge float64   `json:"service_charge"`
	Payable       float64   `json:"payable"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.queryRow(ctx, q.createOrderStmt, createOrder,
		arg.CustomerID,
		arg.Status,
		arg.PaymentMethod,
		arg.PaymentStatus,
		arg.RiderNote,
		arg.DispatchTime,
		arg.Total,
		arg.TotalDiscount,
		arg.ServiceCharge,
		arg.Payable,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Status,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.RiderNote,
		&i.DispatchTime,
		&i.Total,
		&i.TotalDiscount,
		&i.ServiceCharge,
		&i.Payable,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (order_id, product_id, brand_id, price, quantity, discount)
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, order_id, product_id, brand_id, price, quantity, discount, created_at, updated_at
`

type CreateOrderItemParams struct {
	OrderID   int64   `json:"order_id"`
	ProductID int64   `json:"product_id"`
	BrandID   int64   `json:"brand_id"`
	Price     float64 `json:"price"`
	Quantity  int32   `json:"quantity"`
	Discount  float64 `json:"discount"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.queryRow(ctx, q.createOrderItemStmt, createOrderItem,
		arg.OrderID,
		arg.ProductID,
		arg.BrandID,
		arg.Price,
		arg.Quantity,
		arg.Discount,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.BrandID,
		&i.Price,
		&i.Quantity,
		&i.Discount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRiderAssign = `-- name: CreateRiderAssign :one
INSERT INTO rider_assign (order_id, rider_id)
VALUES ($1, $2) RETURNING id, order_id, rider_id, created_at
`

type CreateRiderAssignParams struct {
	OrderID int64 `json:"order_id"`
	RiderID int64 `json:"rider_id"`
}

func (q *Queries) CreateRiderAssign(ctx context.Context, arg CreateRiderAssignParams) (RiderAssign, error) {
	row := q.queryRow(ctx, q.createRiderAssignStmt, createRiderAssign, arg.OrderID, arg.RiderID)
	var i RiderAssign
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.RiderID,
		&i.CreatedAt,
	)
	return i, err
}

const getBrandOrder = `-- name: GetBrandOrder :one
SELECT id, brand_id, order_id, status, total, discount, note FROM brand_orders WHERE order_id = $1
`

func (q *Queries) GetBrandOrder(ctx context.Context, orderID int64) (BrandOrder, error) {
	row := q.queryRow(ctx, q.getBrandOrderStmt, getBrandOrder, orderID)
	var i BrandOrder
	err := row.Scan(
		&i.ID,
		&i.BrandID,
		&i.OrderID,
		&i.Status,
		&i.Total,
		&i.Discount,
		&i.Note,
	)
	return i, err
}

const getDeliveryAddress = `-- name: GetDeliveryAddress :one
SELECT id, order_id, customer_id, address, geo_point, apartment, area, floor, phone FROM delivery_address WHERE order_id = $1
`

func (q *Queries) GetDeliveryAddress(ctx context.Context, orderID int64) (DeliveryAddress, error) {
	row := q.queryRow(ctx, q.getDeliveryAddressStmt, getDeliveryAddress, orderID)
	var i DeliveryAddress
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.CustomerID,
		&i.Address,
		&i.GeoPoint,
		&i.Apartment,
		&i.Area,
		&i.Floor,
		&i.Phone,
	)
	return i, err
}

const getOrder = `-- name: GetOrder :one
SELECT id, customer_id, status, payment_method, payment_status, rider_note, dispatch_time, total, total_discount, service_charge, payable, created_at, updated_at FROM orders WHERE id = $1
`

func (q *Queries) GetOrder(ctx context.Context, id int64) (Order, error) {
	row := q.queryRow(ctx, q.getOrderStmt, getOrder, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Status,
		&i.PaymentMethod,
		&i.PaymentStatus,
		&i.RiderNote,
		&i.DispatchTime,
		&i.Total,
		&i.TotalDiscount,
		&i.ServiceCharge,
		&i.Payable,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderItem = `-- name: GetOrderItem :one
SELECT id, order_id, product_id, brand_id, price, quantity, discount, created_at, updated_at FROM order_items WHERE order_id = $1
`

func (q *Queries) GetOrderItem(ctx context.Context, orderID int64) (OrderItem, error) {
	row := q.queryRow(ctx, q.getOrderItemStmt, getOrderItem, orderID)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductID,
		&i.BrandID,
		&i.Price,
		&i.Quantity,
		&i.Discount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRiderAssign = `-- name: GetRiderAssign :one
SELECT id, order_id, rider_id, created_at FROM rider_assign WHERE order_id = $1
`

func (q *Queries) GetRiderAssign(ctx context.Context, orderID int64) (RiderAssign, error) {
	row := q.queryRow(ctx, q.getRiderAssignStmt, getRiderAssign, orderID)
	var i RiderAssign
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.RiderID,
		&i.CreatedAt,
	)
	return i, err
}

const listBrandOrdersByBrandId = `-- name: ListBrandOrdersByBrandId :many
SELECT id, brand_id, order_id, status, total, discount, note FROM brand_orders WHERE brand_id = $1 ORDER BY id Limit $2 OFFSET $3
`

type ListBrandOrdersByBrandIdParams struct {
	BrandID int64 `json:"brand_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) ListBrandOrdersByBrandId(ctx context.Context, arg ListBrandOrdersByBrandIdParams) ([]BrandOrder, error) {
	rows, err := q.query(ctx, q.listBrandOrdersByBrandIdStmt, listBrandOrdersByBrandId, arg.BrandID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BrandOrder{}
	for rows.Next() {
		var i BrandOrder
		if err := rows.Scan(
			&i.ID,
			&i.BrandID,
			&i.OrderID,
			&i.Status,
			&i.Total,
			&i.Discount,
			&i.Note,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBrandOrdersByOrderId = `-- name: ListBrandOrdersByOrderId :many
SELECT id, brand_id, order_id, status, total, discount, note FROM brand_orders WHERE order_id = $1
`

func (q *Queries) ListBrandOrdersByOrderId(ctx context.Context, orderID int64) ([]BrandOrder, error) {
	rows, err := q.query(ctx, q.listBrandOrdersByOrderIdStmt, listBrandOrdersByOrderId, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BrandOrder{}
	for rows.Next() {
		var i BrandOrder
		if err := rows.Scan(
			&i.ID,
			&i.BrandID,
			&i.OrderID,
			&i.Status,
			&i.Total,
			&i.Discount,
			&i.Note,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrder = `-- name: ListOrder :many
SELECT id, customer_id, status, payment_method, payment_status, rider_note, dispatch_time, total, total_discount, service_charge, payable, created_at, updated_at FROM orders ORDER BY id Limit $1 OFFSET $2
`

type ListOrderParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListOrder(ctx context.Context, arg ListOrderParams) ([]Order, error) {
	rows, err := q.query(ctx, q.listOrderStmt, listOrder, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Status,
			&i.PaymentMethod,
			&i.PaymentStatus,
			&i.RiderNote,
			&i.DispatchTime,
			&i.Total,
			&i.TotalDiscount,
			&i.ServiceCharge,
			&i.Payable,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrderByCustomerId = `-- name: ListOrderByCustomerId :many
SELECT id, customer_id, status, payment_method, payment_status, rider_note, dispatch_time, total, total_discount, service_charge, payable, created_at, updated_at FROM orders WHERE customer_id = $1 ORDER BY id Limit $2 OFFSET $3
`

type ListOrderByCustomerIdParams struct {
	CustomerID int64 `json:"customer_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

func (q *Queries) ListOrderByCustomerId(ctx context.Context, arg ListOrderByCustomerIdParams) ([]Order, error) {
	rows, err := q.query(ctx, q.listOrderByCustomerIdStmt, listOrderByCustomerId, arg.CustomerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Status,
			&i.PaymentMethod,
			&i.PaymentStatus,
			&i.RiderNote,
			&i.DispatchTime,
			&i.Total,
			&i.TotalDiscount,
			&i.ServiceCharge,
			&i.Payable,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrderItemsByBrandId = `-- name: ListOrderItemsByBrandId :many
SELECT id, order_id, product_id, brand_id, price, quantity, discount, created_at, updated_at FROM order_items WHERE brand_id = $1 ORDER BY id Limit $2 OFFSET $3
`

type ListOrderItemsByBrandIdParams struct {
	BrandID int64 `json:"brand_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) ListOrderItemsByBrandId(ctx context.Context, arg ListOrderItemsByBrandIdParams) ([]OrderItem, error) {
	rows, err := q.query(ctx, q.listOrderItemsByBrandIdStmt, listOrderItemsByBrandId, arg.BrandID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderItem{}
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.BrandID,
			&i.Price,
			&i.Quantity,
			&i.Discount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrderItemsByOrderId = `-- name: ListOrderItemsByOrderId :many
SELECT id, order_id, product_id, brand_id, price, quantity, discount, created_at, updated_at FROM order_items WHERE order_id = $1
`

func (q *Queries) ListOrderItemsByOrderId(ctx context.Context, orderID int64) ([]OrderItem, error) {
	rows, err := q.query(ctx, q.listOrderItemsByOrderIdStmt, listOrderItemsByOrderId, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderItem{}
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.BrandID,
			&i.Price,
			&i.Quantity,
			&i.Discount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRiderAssignByRiderId = `-- name: ListRiderAssignByRiderId :many
SELECT id, order_id, rider_id, created_at FROM rider_assign WHERE rider_id = $1 ORDER BY id Limit $2 OFFSET $3
`

type ListRiderAssignByRiderIdParams struct {
	RiderID int64 `json:"rider_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) ListRiderAssignByRiderId(ctx context.Context, arg ListRiderAssignByRiderIdParams) ([]RiderAssign, error) {
	rows, err := q.query(ctx, q.listRiderAssignByRiderIdStmt, listRiderAssignByRiderId, arg.RiderID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RiderAssign{}
	for rows.Next() {
		var i RiderAssign
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.RiderID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
